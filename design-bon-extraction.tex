\section{\textsc{bon} extraction}The \textsc{bon} extractor is a static analysis tool that allows the user to get an overview of a program written in Eiffel using EiffelStudio. Its purpose is to take use of the features of the \textsc{bon} language without having to leave an Eiffel development environment, and without having to write the actual \textsc{bon}.\subsection{Overall architecture}The \textsc{bon} extractor has two main parts. One is the interface for EiffelStudio; the other is the internal representation of the \textsc{bon} language. Each of the two parts are independent and changes can be done in one without it having any effect, with the exception of feature calls done from one to another. These, however, are few and far between. \paragraph{}For generating textual \textsc{bon} syntax an internal representation of \textsc{bon} has been made. This representation has a MOG-like structure with classes representing most \textsc{bon} structures, with a few exceptions (See section \ref{deviations_from_bon}).  Each of these classes contains the information needed, and knows how to format textual \textsc{bon} (both formal and informal) based on this information. \paragraph{}The objective of the extractor is to build bridge between the Eiffel universe and the \textsc{bon} universe.  In this case EiffelStudio represents the Eiffel universe and the \textsc{bon} universe is represented by an internal \textsc{bon} object graph.\paragraph{}Eiffel -> ? -> \textsc{bon}\subsubsection{From EiffelStudio to BON}To create a bridge between EiffelStudio and the internal \textsc{bon} representation the interface needs to be linked with both parts. It needs be able to take input from EiffelStudio, and hand over the abstract Eiffel syntax to the \textsc{bon} modeling section. In our implementation, it also takes care of knowing whether the current view is informal or formal \textsc{bon}. This could also be handled by the \textsc{bon} modeling section, but as it will be explained in the implementation section(See section \ref{why_interface_takes_care_of_formal_and_informal}) this was not a practical solution.\paragraph{}There now is a link between Eiffel and \textsc{bon}, however the chain is not complete. There is still a missing link in making an internal representation of \textsc{bon} from the abstract syntax.\paragraph{}Eiffel -> Interface -> ? -> \textsc{bon}\paragraph{}To create the \textsc{bon} representation a link (the missing link above) between the abstract syntax and the internal representation is needed. Making a meta-object that instantiates the modeling classes with basis in the abstract Eiffel syntax has done this. This meta-object will inspect the abstract Eiffel syntax and instantiate the \textsc{bon} objects based on the extracted information.\paragraph{}Eiffel -> Interface -> Meta-object -> \textsc{bon}\paragraph{}Since each of these \textsc{bon} objects knows how to generate textual \textsc{bon} syntax from the information given by the meta-object the system is now ready to generate \textsc{bon}. However, the textual \textsc{bon} still needs to be handed back to EiffelStudio for it to be viewed to the user.\paragraph{}Eiffel -> Interface -> Meta-object -> \textsc{bon} \newline    ? <-------------------------------------------------|\subsubsection{From BON to EiffelStudio}Next is the modeling classes handing the formatted \textsc{bon} syntax back to EiffelStudio. To do this either each step towards the syntax needs a reference back to where the textual \textsc{bon} is needed, or each step needs to be able to receiver the result of the following step and hand it back to its predecessor. In our implementation we decided to pass a reference back to the origin all the way to the \textsc{bon} representation, however it is transparent to the creator of the textual \textsc{bon} that it is writing directly to EiffelStudio.\subsubsection{Alternatives}Alternatively : procedural\subsection{Design decisions}\subsubsection{Deviations}\label{deviations_from_bon}