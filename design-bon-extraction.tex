\section{BON extraction}
The \textsc{bon} extractor is a static analysis tool that allows the user to get an overview of a program written in Eiffel using EiffelStudio. Its purpose is to take use of the features of the \textsc{bon} language without having to leave an Eiffel development environment, and without having to write the textual \textsc{bon}.

\subsection{Overall architecture}
The \textsc{bon} extractor has two main parts. One is the interface for EiffelStudio; the other is the internal representation of the \textsc{bon} language. Each of the two parts are independent and changes can be done in one without it having any effect, with the exception of feature calls done from one to another. These, however, are few and far between. 

\paragraph{}
For generating textual \textsc{bon} syntax an internal representation of \textsc{bon} has been made. This representation has a MOG-like structure with classes representing most \textsc{bon} structures, with a few exceptions (See section \ref{deviations_from_bon}).  Each of these classes contains meta information about the structure, and knows how to format textual \textsc{bon} (both formal and informal) based on this information. 

\paragraph{}
The objective of the extractor is to build bridge between the Eiffel universe and the \textsc{bon} universe.  In this case EiffelStudio represents the Eiffel universe and the \textsc{bon} universe is represented by an internal \textsc{bon} object graph.

\paragraph{}
Eiffel $\rightarrow$ ? $\rightarrow$ \textsc{bon}

\subsubsection{From EiffelStudio to BON}
To create a bridge between EiffelStudio and the internal \textsc{bon} representation an interface that is linked with both parts is needed. It needs be able to take input from EiffelStudio, and hand over the abstract Eiffel syntax to the \textsc{bon} modeling section. In this implementation, it also takes care of knowing whether the current view is informal or formal \textsc{bon}. This could also be handled by the \textsc{bon} modeling section, but it will be discussed later, in the implementation section(See section \ref{why_interface_takes_care_of_formal_and_informal}), why this was not a practical solution.

\paragraph{}
With this interface there now is a link between Eiffel and \textsc{bon}, however the chain is not complete. There is still a missing link in making an internal representation of \textsc{bon} from the abstract syntax.

\paragraph{}
Eiffel $\rightarrow$ Interface $\rightarrow$ ? $\rightarrow$ \textsc{bon}

\paragraph{}
To create the \textsc{bon} representation a link (the missing link above) between the abstract syntax and the internal representation is needed. Making a meta-object that instantiates the modeling classes with basis in the abstract Eiffel syntax has done this. This meta-object will inspect the abstract Eiffel syntax and instantiate the \textsc{bon} objects based on the extracted information.

\paragraph{}
Eiffel $\rightarrow$ Interface $\rightarrow$ Meta-object $\rightarrow$ \textsc{bon}

\paragraph{}
Since each of these \textsc{bon} objects knows how to generate textual \textsc{bon} syntax from the information given by the meta-object the system is now ready to generate \textsc{bon}. However, the textual \textsc{bon} still needs to be handed back to EiffelStudio for it to be viewed to the user.

\paragraph{}
Eiffel $\rightarrow$ Interface $\rightarrow$ Meta-object $\rightarrow$ \textsc{bon} \newline
arrow back to eiffel

\subsubsection{From BON to EiffelStudio}
Next step is for the modeling classes to hand back the formatted \textsc{bon} syntax to EiffelStudio for it to be shown to the user. To do this each previous step either needs a reference back to where the textual \textsc{bon} is needed, or to be able to receive the result of the following step and hand it back to its predecessor. In this implementation it has been decided to pass a reference back to the origin all the way to the \textsc{bon} representation, however it is transparent to the creator of the textual \textsc{bon} that it is writing directly to EiffelStudio.

\subsubsection{Alternatives}
This way of extracting \textsc{bon} from Eiffel has the feel of a visitor pattern, but is not quite the same. This raises the question; why not use a visitor pattern? Had it been the intension to use the \textsc{bon} extractor for multiple languages a visitor pattern would have had its benefits, but since it is not the intension of the \textsc{bon} extractor to be used for any other language than Eiffel, a visitor pattern would only cause a more cluttered structure. Furthermore it would require all \textsc{bon} generation to be located in one classes. This would lead to a confusing centralized structure and in the case of extending the \textsc{bon} generator would make it harder to locate where to extend the code. There would both be objects holding the data and representing the \textsc{bon} structure and be a central class taking care of handling the information.
\paragraph{}
An alternative solution would to only have a central class taking care of all the generation. This would require less overhead than the decided on solution since it would remove the need for a meta-object and the need for the MOG-like representation of the \textsc{bon} grammar. This would however, like the visitor pattern, create a chaotic structure with all generation happening in a single class, and would make extension difficult. A procedural approach like this just does not feel in line with the object-oriented ideas involved in Eiffel and \textsc{bon}.

\subsection{Design decisions - Deviations from BON}
\label{deviations_from_bon}\cite{walden1995}

